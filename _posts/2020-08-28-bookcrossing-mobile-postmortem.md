---
title: "Bookcrossing Mobile: post mortem"
published: true 
---

Hello! Recently I received copyright infringement notice about my favorite pet project, Bookcrossing Mobile app, and was asked to remove the app from Play Store. On this sad note, I decided to discontinue its development completely and keep its code open and untouched. In this article, I will describe my journey with development of this project, some cool tricks I've learned, as well as provide some description of the project for anyone who may be interested in it. Project will rot quickly and will become mostly unusable after a short period of time (but still may serve as a reference), but my experience working on it might be useful for those who are looking to start some mobile app project alone.

## Backstory

I've started this project to explore RxJava and Firebase, also to build up my portfolio and to learn. Idea came to my mind when I was browsing Play Store in search of the app to exchange books. I've been participating in bookcrossing movement since 2010, when the first shelf appeared in my hometown. It was not systemized, and a lot of books were not registered on the website, mostly because at that time site was quite inconvenient to use, and, if I'm remembering correctly, site was only available in English. So, after not finding the official Bookcrossing app on the Play Store, I decided to create my own app for bookcrossing that will make it easy to release new books and that is convenient to use.

I've created a list of desired features, but there was almost immediately appeared one more problem: main bookcrossing website didn't have any API available. So I had two options: HTML parsing on client to extract some data or go with my own backend.

I've tried to go with Google services, and started researching Google Cloud Platform stuff for backend. GCP is cool, and it offers a lot of really good services, but it all required a lot of effort to invest, and that wasn't what I wanted. Ideally, I would have preferred to spend as little time on backend development as possible, so I can focus mostly on app side.

Thus, I turned my look to Firebase. It was at that time recently acquired by Google, and there was not so much services they offered. But it was quite enough for my needs: Realtime Database was quite enough to store basic data that I had, Cloud Storage fitted perfectly for storing cover images, and Authentication worked just fine for handling users. Plus later I've added Ads and Analytics as a side effect. There was even convenient FirebaseUI wrapper that helped with binding Firebase services with UI.

I had an eye on RxJava for a long time, it seemed for me the good choice for the most Android apps due to its good threading abstractions, concise API and functional programming fleur. Reactive programming didn't seemed too complex for this project for me, and I wanted to improve my knowledge of Rx, so I decided to build my app in Rx-way.

These factors shaped the initial architecture of the app and helped decide how it will look like.

## Initial development

Once I figured out what to do, I chose then-popular MVP architectural pattern for my new app that was implemented with help of Moxy library. It was quite straightforward, given the amount of code on Stackoverflow ready for copying and pasting right into the project. For non-trivial issues I've picked some libraries from Github with decent amount of stars. I followed examples for Firebase setup and for Moxy, without quite thinking about fitting it into the MVP pattern, so I ended up with a lot of Firebase-related code in views and a lot of business logic in presenters, all mixed up. I even tried to write some tests, but it looked for me like there was not so much to test in terms of business logic, so I haven't added any tests. To be frank, it wasn't quite possible to add tests in that situation, because of a coupling business logic with UI, as well as lack of support for tests on Firebase side.

## Release

After I've implemented most of my ideas, I decided to prepare the app for release, but perform some manual testing of the whole app beforehand. I did test each feature in isolation while developing, but now I was checking everything in combination, each user flow I can come up with. There were some annoying issues with styles for toolbar, but nothing critical. I've spent quite a lot of time (couple of days, actually) trying to fix toolbar appearance, but nothing worked. So, out of frustration and poor health I've postponed release for later.

After few months I got back to releasing process and decided to let that pesky toolbar bug into this release. _Spoiler: I've fixed it only three years later with help of Insets._ Also, the other bugs that were here I decided to fix after release, since I considered them minor.

App went live on beta track at some date, and after that I've noticed quite a few crash reports in Crashlytics. I've fixed them immediately.

Mostly app was functional, but first users have uncovered scenarios I wasn't prepared for. For example, some unusual user navigation flows were leading to crash because of uninitialized variable. It took me the whole day to fix.

Another interesting issue was with ads config. I've sourced Firebase Ads integration code from multiple places, and it was complete mess, TBH. Even more, it didn't work on release build because of misconfiguration. It took me 2 days to figure out what was wrong and configure it properly.

I haven't promoted the app anywhere and I haven't bought installs. Not because I'm against it, just didn't wanted to bother with marketing stuff and pay for advertisements, more wanted to focus on improving quality.

## Big refactoring

Time passed, I was slowly improving some features and fixing bugs so I would be able to release to the main track, not beta. And then suddenly Google announced their Jetpack project with migration to AndroidX libraries and many more. I was excited by the new approach Google has taken and wanted to integrate it as soon as possible. But there was a catch: when I started to migrate app to AndroidX, I've noticed that some libraries I've used started breaking the build with AndroidX, even with Jetifier enabled. After digging into the source code I've found that these libraries were using some components of old support libraries that were not migrated to the AndroidX or were removed or renamed. I've also noticed that some important libraries were abandoned by their maintainers. I was unable to migrate them myself because of poor code style of these libraries, as well as the general complexity of the solutions. For example, RxPermissions library used some weird hacks with ActivityCallbacks to provide the ability to request permissions in Rx chain, and I failed to understand what was going on there. And the funniest thing with this library was that actual crutch that broke Jetifier was placed in instrumented tests for this library. Another interesting example was with Moxy library for easier building of MVP pattern classes. Issues with AndroidX here were easy to fix, but it turned out that original developers were unable to maintain this library due to lack of time. It was forked by multiple people later on, and even turned into community-driven project (it started as in-house project inside one software development studio). But it was much later than I've initially started migration.

This all was very frustrating. Amount of work required was immense: I needed to abstract out unmigrated dependencies to replace them, unbind Firebase logic from UI to ease migration and find replacement for non-AndroidX dependencies. All this work took more than a year with breaks, and at this time I was able to update some dependencies with their AndroidX variants. As a side effect, I decided to fix architectural inconsistencies as well and move everything to the one architectural pattern: I've managed to extract Firebase related code to the proper model layer via data sources and repositories, and this helped me to extract logic from presenter to the usecase, reducing presenter size dramatically. Previously I was unable to decouple this logic properly because of composition with UI and poor Dagger setup, but with all this fixed, this presenter started to shine like a freshly painted car. It was quite satisfying to look into git diff for merge commit after I've finished this migration.

I feel like I need to explain what "poor Dagger setup" means. I had some class like `ApiContainer` (I don't remember exact name) where I was injecting Firebase classes in fields, and this class was injected in BasePresenter as `dagger.Lazy`. This sophisticated optimization coupled each presenter to the base, even if it didn't need any of the Firebase classes, because for some mysterious reason I didn't know about constructor injection. I've started to inject required classes directly in the presenter where they were needed, inlining some base class methods and refactoring some logic. This allowed me to remove `BasePresenter` completely, as well as `ApiContainer`, and that alone simplified all my presenters dramatically and allowed me to see where I can do further improvements.

## State after refactoring

After post-refactoring release was live, I had some time thinking what I can do next. There were quite a lot of things that bugged me, and I wanted to improve them. I decided to create Github Project to sort them out, as well as to test this feature. We didn't use Github at work, so I was curious to learn how it works and is it any useful for project management. Over the years, a lack of tests became the most pain in the bum. You can definitely live happily without any test in your project, they say, but in practice I learned that the presence of tests indicates good health of the project and allows you to iterate faster, despite it takes more time to write tests initially. It was discussed many times over the years in the industry, but for me tests are the must have in any project.

At that stage, most of the logic wasn't testable due to binding of some Firebase related classes to UI just for loading a cover image from Cloud Storage. Untangling it required a few weeks of work, mostly to extract logic to appropriate layers. I chose Fernando Cejas' clean architecture approach with use cases, repositories and datasources. It looked like an overcomplication at first, but I decided to keep retrieval logic in the datasources, and put parsing and mapping in the repositories that depend on those datasources. And logic resided in the usecases named after specific action user needed to perform, like add books to "stash" (favorites list) or claim book via scanning its QR code. All these layers were covered with exhaustive tests. In the end I've got a fine looking presenters with nicely composed Rx chains that I was finally able to cover with tests, but realized that there was no need to cover presenters since logic was already tested, and presenters were only acting as the holders of usecases and Rx subscriptions. Also I ditched an old RxJava adapter library for Firebase, because it was the main problem for refactorings and it wasn't completely thread-safe, so I rewrote adapter functions inside my datasources.

As the next step, I decided to reimplement book position. Initially, I was resolving book position inside the special Cloud Function by the position's name provided by the user and user's city. After some time in production I found out that it doesn't work most of the time, because users tend to write descriptions of the places that are not easily searchable on the map, i.e. not the names of the places, like "Stan's Coffee shop", but something more descriptive about the place, like "At my apartments" or "Shelf near the entrance to the library". I initially wanted to add location picker, but it seemed too complex, thus I ended up implementing this weird automatic resolver. Though it was fun to work with Cloud Functions when they were just released, I decided to remove this broken automation and implement proper location picker. As a map provider, I chose Mapbox that seemed to be great alternative to the Google Maps that is more detailed and is more convenient to use. This was a huge mistake and a lot of frustration.

## Buried plans

## Conclusion
